# Software Develop*er* Lifecycle (SDLC)

- Throughout University the path is pretty clear. Go to class, or at least read the slides, do the homework and occasionally go to a tutorial session or your smart friends to beg for help (pre-chatgpt days). Also, do some leetcode questions and try to build some cool things the side. 
- When you enter your career as a software developer you suddenly realize you are in a totally different world. For some that are lucky this is in some internships/co-ops, for many others these days, it is after they have worked their butt off to find role that will take a chance on new dev. 
- For most roles, computer science folk enter the job market wondering where how they will write their first API in O(N) time complexity. Software engineering graduates stress about how to properly use git and what the hell CI/CD is? 
- But worse, most do not even know what actually matters when you become a software engineer. What are my career paths as a software engineers? Do I have to become a manager to grow in my career? What matters most at the different levels of software engineering? 

# Why Care About Your Career

- Before diving into learning how you might understand and excel as a software engineer, I realized I should take moment to explain why I think it matters. For me, it is not about being devoted to the corporate ladder or trying to get a great title to impress my friends; although it does get a laugh to say at a party that "I am a very wise and experienced 25 year old *Senior* Engineer". 
- Much of it to me comes from Cal Newport and his writing, specifically his book "So Good They Can't Ignore You". Here he introduces the idea that "Skills Trump Passion in the Quest for Work You Love". 
- Furthermore, he goes on that you shoud build what he calls “career capital”: the rare and valuable skills you accumulate so you can later spend them on a career that fits you. In team form, that idea becomes: become so good at something that you earn interesting problems to solve. Not even just as in someone gifts you these special tasks, but that when you seek to solve an interesting problem that calls for you, you are capable of executing that.
- Cal also adds that skill mastery isn’t just for career satisfaction; it’s how we invent the future, earn autonomy, and ultimately choose the direction of our own work, rather than being passengers to it. 
- Here on this team we have the rare opportunity of creating new and useful things with high automony and ceiling for learning with a safety net of a great culture and leadership chain. Take advantage of it.

# Map of a Successful Software Developer Career
- As many of you know, these ideas are not concepts I was stumbled on originally, most of them are from some of the several amazing books I was lucky enough to find. They present these ideas much better than I can and I recommend you read them, but it just takes a bit longer.
We will follow a similar structure to the Software Engineering Guidebook by Gergely Orsov with my own filter and other ideas from The  Talking with Tech Leads by Patrick Kua, Staff Engineer by Will Larson, and The Staff Engineer's Path by Tanya Reilly. 
1. Developer Career Foundations
2. The Competent Software Developer
3. The Well-Rounded Software Engineer
4. The Pragmatic Tech Lead
5. Role-Model Staff and Principal Engineers

# Developer Career Foundations
## Career Paths
At companies where engineering grows beyond ~50 people, the dual path career ladder is typically found.
   IC Ladder              | Manager Ladder
1. Software Engineer      | 
2. Senior Engineer        |
3. Staff Engineer         | Manager / STO 
4. Senior Staff Engineer  | Director
5. Principal Engineer     | Managing Director
...

This allows people to progress in their career without being forced into management. Switching between the IC and Management tracks is more common than you would think. This allows for a very powerful perspective growing teams and growing org's technology. Often the best managers are the ones that you have to rip the keyboards out of their hands, but it is a very different skillset and is humbling.

## Owning your Career
The best advice I received as a software engineer was to own my career. Nobody will care about your growth unless you do. 

I have had several managers already in my career, some care about your aspirations and some care... less. As a tech lead I really care about the growth of my teammates and noticed a few things:
- Sometimes I could tell that no one really asked about their goals in an honest conversation beyond the interview.
- Some people are easier to help than others. I had better conversations with those who knew what they wanted relative to those who didn't want to think about it much. 
- I want to help everyone, but need to admit that the real best person to help do this is themselves; by taking the initiative, being reflective, setting goals, and continously improving.

## Be Someone Who Gets Things Done
If you are not someone who get's things done, almost nothing else matters for your career. Pretty simple, work hard to finish the tasks you are assigned with enough quality at a decent pace. Over-deliver when you can. Also aim to get impactful things done. How to know what is impactful, understand your team and your customer's priorities, so ask questions accordingly.

## Ask For Feedback
Asking for feedback (genuinely) is one of the best ways to learn and grow. Try to avoid asking for general feedback, instead ask about specific things you worked on or led. Some examples include:
- Code review to improve your code
- Ideas and proposals to get thoughts and alignment
- Feature deliver (how did my owning this feature go?)
- Design documents; data design, solution diagram
Remember, feedback is a gift.

## Make Your Manager Your Ally
Your manager (in our case partially your tech lead) is the colleague who has the single biggest impact on your career within the company. A leader who believes in you, advocates for you, and supports you in your career goals makes a huge difference. So how can you move towards this?
1. Have a regular 1:1 time with your manager; discuss what you have been working on, talk about your goals and challenges
2. Understand your leader(s) goals; get a sense of what is important for the team, ask about what is the biggest upcoming challenges for the next month and half year
3. Establish trust; it's earned over time, aim to be honest and transparent with them.
4. Get your work recognized; present great work in larger team meetings, this is good for both your promotion case and your team.

## Pace Yourself
Athletes pace themselves for peak performance. In a similar fashion, the "stretching, executing, and coasting" model is useful.
- Stretching; most fun for some time, learning and applying to challenges. Can cause burnout. (starting)
- Executing; normal way of working, pull your weight and sometime go beyond it. Like doing something you're familiar with
- Coasting; doing less and lower quality, typically temporary. More than a few days is counterproductive to the team and obvious to others.

Mix these up to optimize for long term professional growth.

# The Competent Software Developer
## General Expectations
table

## Getting things done
As a tech lead I always have good sense of which engineers get things done reliably. Every manager and lead has this idea in their head, and when an important project or feature comes up they look to these individuals, leading to higher visibility, more challenging tasks, accelerating your learning. Plus you will get the increased autonomy that comes with trust. So how can you do this?

1. Focus on the most important piece of work. 
- On our team there are always items to work on. Instead of being overwhelmed, ask yourself if you only got one thing done this week what would it be? What about one thing tomorrow? Make a habit of always completing this #1 priority and work with your lead/manager to ensure you have been accurately assessing this priority.
2. Unblock yourself
- Building software has many unforseen obstacles, like strange error messages that google/copilot does not help with. Couple tips here to get over this; 
    a. Know when you are blocked, maybe 30mins to 1hr of no progress, admit it. Try rubber duckering your approach. Draw it out. Read some docs. Take a break and go for a walk. 
    b. Second is get support to unblock yourself. Often this is just not having enough information. When you ask someone for help, make sure you make it as easy as possible to help, have your thoughts organized and drawn/written out, ask clarifying questions. But then to keep the trust with the individual helping, try to make sure you understand the issue and solution so you know how to resolve it next time. Keep a note somewhere called issues and resolutions if this is happening to you often. When Vidhya helps me solve something tricky, I try to probe his brain for how he found the clues if it is not clear to me.
3. Break down the work
- Try to understand the "why" you are working on something. How does this effect the end user?
- Turn that into stories, then you can figure out the tasks to get that user story complete. If you are struggling with ambiguity/complexity break that down into subtasks.
4. Seek mentors
- You are on a team with some very smart individuals and lucky that they are all kind and helpful. Ask for 1:1s with them, try to understand how they got good at what they are good at, ask them for feedback/thoughts on something you are working on. I love learning what resources and experiences have helped my teammates like Kirill and Rob have learned from to have such great technical knowledge early in their career.
5. Take the initiative
- The most productive engineers I have worked with take on opportunities they see in front of them to learn and try things. I earned respect from my colleagues and execs when I joined BMO by quickly becoming the graph database expert. At fast growing and dynamic teams like our own, there are many opportunities to take this on. 
- You can try, documenting unclear things, investigating new tools or frameworks, and talking with your manager about upcoming projects

## Coding
Writing Code is still the core of software engineering. 

## Practice Coding... A Lot!
You want to be able to translate ideas into working code, the essential skill. Some main approaches you can take to get there are code regularly, learn a language in depth, and solve real world problems. 

1. Code Regularly
- You can read all you want about the specifics of coding, but as with any sports training, the biggest contributor to your progress is how much you practice. Coding daily is a great habit that will bring you from alright to much more comfortable. If you feel this is a weakness for you, it is worth the extra practice or reprioritizing of your work to ensure you are writing code for some large portion of the day. No real substitute for this.
2. Code Review
- Aim to get feedback on all the code you write, even if it is not required. These days it is as simple as asking copilot for a code review on your PR or probing it on specific decisions you made in your code. We have many talented devs on this team, and asking for direct feedback is a great way to improve. 
3. Read about as much as you write
- Reading code is great way to learn new things and better practices, in my view checking out someones code and trying to run it / improve it is a really awesome way to dig deep here. Reading open-source code is another amazing way of learning, try to find a open source project that you use or are interested in like React or Bun. You can check out the changes and/or resolved issues to make sense of what is happening and the feedback reviewers give.

## Software Development
1. Become proficient in a language
- Learn a language really well. You hit a new level of comprehension when you know the syntax, constructs, operators, best practices. Go under the hood for details like how memory work, how the code compiles, and what matters for performance. You can take the books approach to this or just be curious and ask what actually happens when you declare a function or find some tooling to peek under the hood like Clinic.js. It is often more effective for devs to go deep earlier in their career than broad.
2. Be great at debugging
- If you can debug quickly and efficiently, you can iterate and learn quicker. Often times it is about setting yourself up for success, or being Vidhya and having an encyclopedia of knowledge for finding bugs. Several times I realized that my code was written in a hard to debug way. Try to make smaller changes and test them often, whether that is setting up tests or being great at using a debugging tool like Rob. Whenever I get support one of the great devs on our team I try to observe how they debug and what they look for, try to learn from it rather than just happy your problem is solved. Also, the earlier in your dev cycle you can test, the better, do not deploy to AWS to test non-integration code unless you need to.
3. Refactoring
- An often overlooked part of coding, refactoring can help you adjust the code so it evolves over time due to the new information and requirements. Try to refactor your code every time you write it, similar to that red, green, refactor loop. Take note of items other devs find confusing in your code and try to adjust with naming or comments accordingly. 
4. Testing
Reliable engineers test their code before requesting a code review or committing it, whether automated or manual. They care about edge cases and potential failure scenarios.

## Tools of the Productive Dev
1. Physical tools
- One item for I have been actively trying to improve over the last little while is my ability to do things faster on my device. For instance typing 70wpm+ and being able to easily use your code editor to run and read code allows you to try your ideas out quicker. Don't let this be the bottleneck for you.
2. Local development tools
- Be able to quickly compile/run your code to check for issue and run specific tests to achieve a quick output cycle so you can stay more "in the zone". This is another one where you can learn from watching other talented devs on our team.
- Be able to use the command line/terminal and common tools like git well.
- Finally, experiment with AI tools. While some are bigger fans than others, try working in small slices and getting it to automate things for you where you know what you want to do but want copilot to do it faster. This deserves its own presentation.
3. Ways to iterate quickly/experiment
- You need to have a good understanding of your projects existing code and what it does. Figure this out by having someone walk you through the structure and/or draw out the modules and how they connect
- Understand how to debug the CI/CD. This requires having a baseline knowledge of the environment you are deploying to and where to look when things go wrong (CDK Deploy Step, Cloudformation, CodeDeploy logs). There are many things to understand here, like what you have access to do, what logs you should check, and what dashboards to look at for metrics.

## Summary
Competent Software Developers get things done reliably. The single best advice for this level is practice, practice, practice. Spend lots of time coding and learning how to improve your coding quality and processes from other developers. Laying this foundation will pay dividends for your career beyond this point.
